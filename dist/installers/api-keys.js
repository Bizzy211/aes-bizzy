/**
 * API Keys management for A.E.S - Bizzy ecosystem
 *
 * Handles collection, storage, and retrieval of API keys
 * stored in ~/.claude/aes-bizzy.env
 */
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { existsSync } from 'node:fs';
import { homedir } from 'node:os';
import * as prompts from '@clack/prompts';
import { executeCommand } from '../utils/shell.js';
import { createLogger } from '../utils/logger.js';
const logger = createLogger({ context: { module: 'api-keys' } });
/**
 * Get the path to aes-bizzy.env
 */
export function getEnvPath() {
    return path.join(homedir(), '.claude', 'aes-bizzy.env');
}
/**
 * Auto-detect GitHub token using gh CLI
 */
export async function detectGitHubToken() {
    try {
        const result = await executeCommand('gh', ['auth', 'token']);
        if (result.exitCode === 0 && result.stdout.trim()) {
            return result.stdout.trim();
        }
    }
    catch (error) {
        logger.debug('Failed to auto-detect GitHub token:', error);
    }
    return null;
}
/**
 * API key definitions for the ecosystem
 */
export const API_KEY_DEFS = [
    {
        key: 'GITHUB_TOKEN',
        name: 'GitHub Token',
        description: 'For repo sync and GitHub Issues integration',
        required: true,
        autoDetect: detectGitHubToken,
        validate: (v) => v.startsWith('ghp_') || v.startsWith('gho_') || v.startsWith('github_pat_'),
        hint: 'Auto-detected from gh CLI',
    },
    {
        key: 'EXA_API_KEY',
        name: 'Exa.ai API Key',
        description: 'For code search and web research',
        required: true,
        validate: (v) => v.length > 10,
        hint: 'Get from exa.ai dashboard',
    },
    {
        key: 'REF_API_KEY',
        name: 'Ref.tools API Key',
        description: 'For documentation lookup',
        required: true,
        validate: (v) => v.startsWith('ref-'),
        hint: 'Get from ref.tools',
    },
    {
        key: 'ANTHROPIC_API_KEY',
        name: 'Anthropic API Key',
        description: 'For TaskMaster AI and Claude models',
        required: false,
        validate: (v) => v.startsWith('sk-ant-'),
        hint: 'Optional - for TaskMaster',
    },
    {
        key: 'PERPLEXITY_API_KEY',
        name: 'Perplexity API Key',
        description: 'For research features',
        required: false,
        validate: (v) => v.startsWith('pplx-'),
        hint: 'Optional - for research',
    },
];
/**
 * Load existing API keys from aes-bizzy.env
 */
export async function loadApiKeys() {
    const envPath = getEnvPath();
    const keys = {};
    if (!existsSync(envPath)) {
        return keys;
    }
    try {
        const content = await fs.readFile(envPath, 'utf-8');
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            // Skip comments and empty lines
            if (!trimmed || trimmed.startsWith('#'))
                continue;
            const eqIndex = trimmed.indexOf('=');
            if (eqIndex > 0) {
                const key = trimmed.slice(0, eqIndex).trim();
                let value = trimmed.slice(eqIndex + 1).trim();
                // Remove quotes if present
                if ((value.startsWith('"') && value.endsWith('"')) ||
                    (value.startsWith("'") && value.endsWith("'"))) {
                    value = value.slice(1, -1);
                }
                keys[key] = value;
            }
        }
    }
    catch (error) {
        logger.debug('Failed to load existing API keys:', error);
    }
    return keys;
}
/**
 * Save API keys to aes-bizzy.env
 */
export async function saveApiKeys(keys) {
    const envPath = getEnvPath();
    const claudeDir = path.dirname(envPath);
    // Ensure ~/.claude exists
    await fs.mkdir(claudeDir, { recursive: true });
    const lines = [
        '# A.E.S - Bizzy Ecosystem Configuration',
        `# Generated by: aes-bizzy init on ${new Date().toISOString()}`,
        '#',
        '# This file contains API keys for the A.E.S - Bizzy ecosystem.',
        '# Keep this file secure and do not commit to version control.',
        '',
    ];
    // Add keys with comments
    for (const def of API_KEY_DEFS) {
        const value = keys[def.key];
        if (value) {
            lines.push(`# ${def.name}: ${def.description}`);
            lines.push(`${def.key}=${value}`);
            lines.push('');
        }
    }
    // Add any extra keys not in our definitions
    for (const [key, value] of Object.entries(keys)) {
        if (value && !API_KEY_DEFS.find(d => d.key === key)) {
            lines.push(`${key}=${value}`);
        }
    }
    await fs.writeFile(envPath, lines.join('\n'), 'utf-8');
    logger.debug(`Saved API keys to ${envPath}`);
}
/**
 * Collect API keys interactively
 */
export async function collectApiKeys(existingKeys = {}, options = {}) {
    const keys = { ...existingKeys };
    const envPath = getEnvPath();
    // Merge provided keys (from CLI flags)
    if (options.providedKeys) {
        for (const [key, value] of Object.entries(options.providedKeys)) {
            if (value) {
                keys[key] = value;
            }
        }
    }
    // Process each key definition
    for (const def of API_KEY_DEFS) {
        // Skip if already have a valid value
        if (keys[def.key] && (!def.validate || def.validate(keys[def.key]))) {
            continue;
        }
        // Try auto-detection
        if (def.autoDetect) {
            const detected = await def.autoDetect();
            if (detected) {
                keys[def.key] = detected;
                prompts.log.success(`${def.name}: Auto-detected âœ“`);
                continue;
            }
        }
        // Non-interactive mode: skip optional, fail on required
        if (options.nonInteractive) {
            if (def.required && !keys[def.key]) {
                return {
                    success: false,
                    keys,
                    envPath,
                    error: `Missing required key: ${def.key}`,
                };
            }
            continue;
        }
        // Interactive prompt
        if (def.required || await shouldPromptOptional(def)) {
            const value = await prompts.text({
                message: `${def.name}`,
                placeholder: def.hint || `Enter ${def.key}`,
                validate: (v) => {
                    if (def.required && !v)
                        return `${def.name} is required`;
                    if (v && def.validate && !def.validate(v)) {
                        return `Invalid ${def.name} format`;
                    }
                    return undefined;
                },
            });
            if (prompts.isCancel(value)) {
                return {
                    success: false,
                    keys,
                    envPath,
                    error: 'Cancelled by user',
                };
            }
            if (value) {
                keys[def.key] = value;
            }
        }
    }
    return {
        success: true,
        keys,
        envPath,
    };
}
/**
 * Ask if user wants to provide an optional key
 */
async function shouldPromptOptional(def) {
    const result = await prompts.confirm({
        message: `Configure ${def.name}? (${def.description})`,
        initialValue: false,
    });
    return result === true;
}
/**
 * Full API key setup flow for init wizard
 */
export async function setupApiKeys(options) {
    // Load existing keys
    const existingKeys = await loadApiKeys();
    // Collect/update keys
    const result = await collectApiKeys(existingKeys, {
        nonInteractive: options.nonInteractive,
        providedKeys: options.providedKeys,
    });
    if (!result.success) {
        return result;
    }
    // Save updated keys
    try {
        await saveApiKeys(result.keys);
        prompts.log.success(`API keys saved to ${result.envPath}`);
    }
    catch (error) {
        return {
            success: false,
            keys: result.keys,
            envPath: result.envPath,
            error: `Failed to save keys: ${error instanceof Error ? error.message : String(error)}`,
        };
    }
    return result;
}
/**
 * Get a specific API key (loads from file if needed)
 */
export async function getApiKey(key) {
    const keys = await loadApiKeys();
    return keys[key];
}
/**
 * Check if required API keys are configured
 */
export async function checkRequiredKeys() {
    const keys = await loadApiKeys();
    const missing = [];
    const configured = [];
    for (const def of API_KEY_DEFS) {
        if (keys[def.key]) {
            configured.push(def.key);
        }
        else if (def.required) {
            missing.push(def.key);
        }
    }
    return {
        valid: missing.length === 0,
        missing,
        configured,
    };
}
//# sourceMappingURL=api-keys.js.map